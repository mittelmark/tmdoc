---
title: tmdoc::tmdoc 0.14.0 - Tcl Markdown processor tutorial
author:  Detlef Groth, University of Potsdam, Germany
date: 2025-10-05 08:10
bibliography: ../../examples/literature.bib
abbreviations: abbrev.yml
DG: Detlef Groth, University of Potsdam, Germany
---

```{.tcl label=start1 echo=false results=hide eval=false}
set start [clock milliseconds]
lappend auto_path ..
```

```{.tcl label=start2,echo=false,results=hide,eval=true}
set start [clock milliseconds]
lappend auto_path ..
```

## <a name="abstract">Abstract</a>

In the last years reproducible research has gained focus from the research
community. It is a type of literate programming, introduced by Donald Knuth in
1984, where code of a programming language is embedded within standard text
documents, like LaTeX or Markdown documents. The code is evaluated and
adds or replaces it's own code with the code output. Alternatively the code chunks as well
as the output result can be also hidden if needed. 

There exist several tools
which allow this type of programming/documenting, for instance for the R
programming language [Knitr](https://yihui.name/knitr) or
[Sweave](https://en.wikipedia.org/wiki/Sweave). Although Knitr is an engine
for dynamic report generation especially for the
statistical language R it supports as well other programming languages such
as for instance Python 3, Perl, Haskell, Ruby and more than 20 others with a
few limitations.

Embedding of Tcl in the Knitr framework is somehow difficult as it has no command
line option to evaluate Tcl code on the fly. There might be workarounds by
creating a Tcl command line application which allows this. Form my perspective however,
the Tcl programming as a mature highly dynamic scripting language
invented by John Ousterhout in 1988, should not need a huge framework to support
literate programming with Tcl itself. Therefore the decision to write a Tcl program to implement a literate programming
package for Tcl just based on standard Tcl which is called *tmdoc::tmdoc*, 
or short just *tmdoc*. In its current state *tmdoc* supports standard code chunks with options to display
and hide code and code output, to embed inside text code evaluations and image
creation. This basic subset of a literate programming environment should be
sufficient to create nice technical and statistical reports, tutorials about
Tcl packages and other types of documentation.

## <a name="toc">Table of Contents</a>

- [Introduction](#intro)
- [Color Codes](#codes)
- [Tcl code chunks](#block)
    - [Standard Code Blocks](#block)
    - [The puts Statement](#puts)
    - [Inline Codes](#inline)
    - [Error Handling](#errors)
    - [Creating Tables](#tables)
    - [Including Files](#include)
    - [Writing Images with tsvg](#images)
- [Command Line Tools (GraphViz, GO games ...) ](#clp)
- [Kroki Diagrams (GraphViz, PlantUML, ...)](#kroki)
- [LaTeX Equations and Matrices](#latex)
- [Programming Examples (C, C++, Python)](#programming)
- [References with BibTeX Files](#references)
- [Abbreviations](#abbrev)
- [Alerts](#alerts)
- [CSV Display](#csv)
- [Statistical Reports with R, Python or Octave](#reports)
    - [R](#rreport)
    - [Python](#preport)
    - [Octave](#oreport)
- [Code Chunk Options](#options)
- [Summary](#summary)
- [Installation](#install)
- [See Also](#seealso)
- [Processing Information](#process)

## <a name="intro">Introduction</a>

The Tcl package `tmdoc::tmdoc` which is both a standalone command line
application and as well a Tcl package is a report generator and a literate
programming tool for Tcl. It can capture the results and plots or images from
data analysis and works well with other packages like Tk, or gdtcl. The
current text is a short tutorial on how to do literate programming with Tcl
using the package. Literate programming is a style of progamming where in a
text document, shorter or longer code fragments of a programming language are
embedded. The document is then "weaved", the programming code is replaced with
it's output. The produced document can thereafter be further processed to other
formats.The `tmdoc::tmdoc` package supports Markdown as documentation
language. Using Markdown processors like `pandoc` or the Tcl package
`Markdown` the output of the `tmdoc` processor can be converted finally to
other document formats like pdf or html. 

To give an example, below is the pipleine which was used to create the HTML document you are
currently viewing using [https://github.com/mittelmark/tmdoc](tmdoc) and [https://github.com/mittelmark/mkdoc](mkdoc) :

```{std}
$ tmdoc tmdoc-tutorial.tmd - | \
    mkdoc - tmdoc-tutorial.html --css tmdoc.css 
```

With the [pandoc](https://pandoc.org/) command line application yo can as well convert the Markdown output of *tmdoc* to many other formats. 
The pipeline is then the following:

```{std}
      tmdoc         pandoc
TMD --------> MD ----------> HTML/PDF/DOCX
```

Now the mandatory "Hello World!" example. If you embed the following text
into your Markdown document with the extension, `.tmd`, *tmdoc* will produce, after converting the document
from  Markdown to HTML via *mkdoc* or *pandoc*, the following  input  (replace
the leading single quote with a backtick, necessary here to avoid interpretation by *tmdoc*) 

```{std}
'``{.tcl}
puts "Hello World!"
'``
```

will produce this output:

```{.tcl}
puts "Hello World!"
```

Code block and/or the output can be as well hidden using chunk arguments, that
will be described later in more detail. Short code fragments can be 
directly embedded into the text. Here an example for this approach:

```{std}
The curent date and time is: `tcl clock format [clock seconds] -format "%Y-%m-%d %H:%M"`
```

This is the output:

The curent date and time is: `tcl clock format [clock seconds] -format "%Y-%m-%d %H:%M"`

----

## <a name="codes">Color Codes</a>

Now follows a short tutorial for the features of the *tmdoc* Markdown processor.
For the code blocks the following color codes are used, grey is example Tcl
code which is not evaluated by Tcl, it shows mainly how the code chunks looks in the Markdown document, in creme is Tcl code which is evaluated,
in blue is the output of the creme tcl code before. Red code lines indicate code errors.

So here again the color codes:

```{std}
gray: code examples which are not evaluated within this document
```

```{tclcode}
creme: code examples which are evaluated by Tcl
```

```{tclout}
blue: result output of evaluated Tcl code
```

```{tclerr}
red: errors resulting from Tcl code evaluations
```

## <a name="block">Standard Code Blocks</a>

Standard code block are started with three tickmarts at the beginning of a
line and in curly brace the string tcl. Separated by a space might follow
several evaluation options which will be described later in more detail.

Here the Tcl-Markdown input (replace the single quote with a backtick):

```{std}
'``{tcl echo=true}
set x 1
set a 1
set a
set x
'``
```

Please note that the indentation is neccessary only for the example here, as
tmdoc is processing tmdoc inside tmdoc. So in fact there should be no four
spaces at the beginning in your code.

And here the resulting output:

```{.tcl echo=true}
set x 1
set a 1
set a
set x
```

Only the last statement is returned. The arrow indicates the return value of
the current code block. You should use *puts* if you need to output more than
the last statement.


## <a name="puts">The puts Statement</a>

You can have several puts statements in your code which are printed
before the final return value. The channel stdout is displayed as well in the
results part. Also the *-nonewline* option can be used:

```{.tcl echo=true}
puts "Hello World 1"
puts "Hello World 2"
set x 3
puts "Hello World $x"
puts stdout "Hello World [incr x]"
puts -nonewline "Hello"
puts " World [incr x]"
puts -nonewline stdout "Hello"
puts stdout " World [incr x]"
# let's reset x to one
set x 1
```

You can as well write into file channels as usually:

```{.tcl}
set out [open file.ext w 0600]
puts $out "Hello File World!"
close $out
# now display the content
set filename file.ext
if [catch {open $filename r} infh] {
    puts stderr "Cannot open $filename: $infh"
    exit
} else {
    while {[gets $infh line] >= 0} {
        puts stdout "file: $line"
    }   
}
```
To supress any output, your last statment should return an empty string:

```{.tcl echo=true}
set a 5
set a ""
```

Alternatively you can supress the output at all by giving an option `results=hide` to the code chunk

```{std}
'``{.tcl results=hide}
set a 1
'``
```

```{.tcl results=hide}
set a 1
```

There is now no output with 1 here to see as we used chunk option `results=hide`.

You can as well supress both showing the Tcl code and the output of the Tcl
code by specifying `results=hide` and `echo=false` as shown in the following example:


```{std}
'``{tcl results=hide,echo=false}
set a 2
'``
    
Our variable a has now a value of `tcl set a` although we don't know why as the programming code is hidden.
```

```{.tcl results=hide,echo=false}
set a 2
```
    
Our variable a has now a value of `tcl set a` although we don't know why.

This feature can be useful if you don't want to show in a final
version of a text document how the computation was done, but only the results
of this computation within the text, for instance to display date and used Tcl packages as can be seen at the very end of this document.


## <a name="inline">Inline Codes</a>

```{std}
Let's look what is the value of x. The value of x is `tcl set x`. Is it one??
```

Let's look what is the value of x. The value of x is `tcl set x`. Is it one??

Yes it is!

Now let's try two times inline code on one line:

```{std}
The value of x is: `tcl incr x` and now `tcl incr x`!.
```

The value of x is: `tcl incr x` and now `tcl incr x`!. So also this works.
Don't write too long Tcl statements directly in the text. You should perform
your major computations in the code blocks. Please note as well, that the inline code chunks can't wrap over multiple lines. So opening and closing backtick must be on the same line.

## <a name="errors">Error Handling</a>

Let's display errors of code blocks:

```{.tcl }
set y 2
set z
```

Should given an error ... It does!

Now check for inline code errors in text:

```{std}
This line contains an inline code error `tcl set z`!!
```

This line contains an inline code error `tcl set z`!!


## <a name="tables">Creating Tables</a>

Since  _tmdoc_  version  0.7.0 there is as well  support for tables  using the
`results=asis` option. Here an example:

```{std}
'``{.tcl results=asis,echo=false}
set h [list A B C]
set d [list 1 2 3 4 5 6 7 8 9]
puts [list2mdtab $h $d]
'``
```

```{.tcl results=asis,echo=false}
set h [list A B C]
set d [list 1 2 3 4 5 6 7 8 9]
puts [list2mdtab $h $d]
```
    
## <a name="include">Including Files</a>

Sometimes we store information which should be available for a set of files in
separate file to reuse this  information in other files. Examples for this are
headers and footers. Let's create such a file here and then include that file.
Let's assume we have a file  lipsum.txt  which  contains Lorem lipsum text. We
can then easily include that file like this:


```{std}
    Some text - indented and emphasized.
    
    > _`tcl include lipsum.txt`_
    
    Some more text.
````

Here the output:

Some text - indented and emphasized.
 
> _`tcl include lipsum.txt`_
 
Some more text.
    


## <a name="images">Writing Images</a>

Displaying images generated by Tcl code is as well possible. Here an example
using the *tsvg* package which is embedded within the tmdoc application:

```{.tcl}
lappend auto_path ..
package require tsvg
tsvg set width 100
tsvg set height 100
# Tcl like syntax without hyphens
tsvg circle cx 50 cy 50 r 45 stroke black stroke-width 2 fill salmon
tsvg text x 29 y 45 Hello
tsvg text x 27 y 65 World!
tsvg write hello-world.svg
### cleanup
tsvg set code ""
```

![](hello-world.svg)

To allow automatic  embedding of the current image you have to create a figure
command like this_

```{.tcl}
proc figure {filename} {
    tsvg write $filename
    tsvg set code ""
    return ""
}   
```

Here an example:

```
'``{.tcl fig=true echo=false results=hide}
tsvg circle -cx 50 -cy 50 -r 45 -stroke black -stroke-width 2 -fill skyblue
tsvg text -x 29 -y 45 Hello
tsvg text -x 23 -y 65 World2!
'``
```

And here the output, only the image should be displayed:

```{.tcl fig=true echo=false results=hide}
tsvg circle -cx 50 -cy 50 -r 45 -stroke black -stroke-width 2 -fill skyblue
tsvg text -x 29 -y 45 Hello
tsvg text -x 23 -y 65 World2!
```


## Pandoc compatible code syntax

Since tmdoc version 0.5 as well Pandoc compatible code chunk options are
supported. For instance spaces after the triple codes are ignored, and chunk
options can be given space separated in addition to the comma separated
approach.

Here an example:

```{unindent}
'`` {.tcl}  
set x 3
puts $x
'``
```

And here the output:

``` {.tcl}  
set x 3
puts $x
```

Now the options: `{.tcl echo=false results="hide"}`

``` {.tcl echo=true results="hide"}  
set x 4
puts $x
```

<a name="clp"> </a>
## Other Command Line Tools

Since  version  0.8.0  there  is  as  well  support  for  embedding  input
for command line applications which produce graphics inside
code  chunks, for  instance using tools like
[GraphViz dot](https://www.graphviz.org), [Pikchr](https://pikchr.org) or 
[PlantUML](https://www.plantuml.com) or even [R](https://www.r-project.org).  To do this you add code chunks with the
`.shell` tag and provide the command to process in the code chunk  options the
command to process the content with the `cmd` attribute. There are as well 
placeholders,  two for the input  filename  `%i` or '%f', one for the basename
of the input file, so the filename without the extension '%b' and one for the output
filename: `%o`. Here an example for using the dot executable:

```
'``{.shell cmd="dot -Tpng %i -o%o" echo=false}
digraph g {
   A -> B
}
'``
```

And here the output:

```{.shell cmd="dot -Tpng %i -o%o" echo=false}
digraph g {
 A -> B
}

```

Let's continue with an example using the `plantuml`  command line application.
Here the output  filename is guessed  from the input  filename, so there is no
need to give the `%o` argument.

```
'``{.shell cmd="plantuml -tpng %i" echo=false}
@startuml
class A { }
class B { }
A -> B
@enduml
'``
```

And here the output:

```{.shell cmd="plantuml -tpng %i" echo=false}
@startuml
class A { }
class B { }
A -> B
@enduml
```

Some  times you would  like to use the same input presented in the code block before but
with  different  command line  arguments. In this case you can add as well the
term  `LASTFILE`  on the first  line of the code chunk to reuse  this. Here an
example to display different moments of a Go board game. So instead of writing again
and again the same long game record in the code chunk you just write the short text
`LASTFILE`  into it. Here an example for this approach  displaying the initial
phase of a 13x13 board game but with  different  command  line options for the
display using the command line tool [sgf-render](https://github.com/julianandrews/sgf-render):

```
'``{.shell cmd="sgf-render %i --format png --outfile %o --width 500 --move-numbers=1-10 -n 10" echo=false}
(;FF[4]
CA[UTF-8]
GM[1]
DT[2025-02-28]
GN[Freundschaftsspiel]
PB[Black Player]
PW[White Player]
BR[15k]
WR[14k]
...
'``
'``{.shell cmd="sgf-render %i --format png --outfile %o --width 500 --move-numbers=11-20 -n 20" echo=false}
LASTFILE
'``

'``{.shell cmd="sgf-render %i --format png --outfile %o --width 500 --move-numbers=21-30 -n 30" echo=false}
LASTFILE
'``
```

And here the ouput (the sgf codes on top where shortened):
    
```{.shell cmd="sgf-render %i --format png --outfile %o --width 500 --move-numbers=1-10 -n 10" echo=false}
(;FF[4]
CA[UTF-8]
GM[1]
DT[2025-02-28]
GN[Freundschaftsspiel]
PB[Black Player]
PW[White Player]
BR[15k]
WR[14k]
TM[432000]OT[86400 fischer]
RE[W+9.5]
SZ[13]
KM[6.5]
RU[Japanese]
;B[jj]
(;W[dd]
(;B[jc]
(;W[dj]
(;B[je]
(;W[hk]
(;B[ik]
(;W[hj]
(;B[cc]
(;W[cd]
(;B[dc]
(;W[ec]
(;B[eb]
(;W[fc]
(;B[bd]
(;W[fb]
(;B[db]
(;W[be]
(;B[ac]
(;W[cf]
(;B[ck]
(;W[cj]
(;B[dk]
(;W[ek]
(;B[el]
(;W[fk]
(;B[fl]
(;W[kg]
(;B[jh]
(;W[jg]
(;B[kh]
(;W[hg]
(;B[bj]
(;W[bi]
(;B[bk]
(;W[le]
(;B[ld]
(;W[kd]
(;B[lg]
(;W[lf]
(;B[lh]
(;W[lc]
(;B[kc]
(;W[jd]
(;B[lb]
(;W[md]
(;B[ic]
(;W[id]
(;B[hc]
(;W[gd]
(;B[hd]
(;W[he]
(;B[gc]
(;W[fd]
(;B[ij]
(;W[hi]
(;B[ih]
(;W[hh]
(;B[hl]
(;W[ha]
(;B[hb]
(;W[ga]
(;B[ia]
(;W[gb]
(;B[jb]
(;W[mb]
(;B[la]
(;W[gl]
(;B[ig]
(;W[if]
(;B[gm]
(;W[gk]
(;B[im]
(;W[aj]
(;B[ak]
(;W[ai]
(;B[mf]
(;W[ae]
(;B[bb]
(;W[ad]
(;B[bc]
(;W[mc]
(;B[ii]
(;W[me]
(;B[mg]
(;W[ea]
(;B[da]
(;W[fa]
(;B[dl]
(;W[ma]
(;B[]
(;W[]
))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
```

```{.shell cmd="sgf-render %i --format png --outfile %o --width 500 --move-numbers=11-20 -n 20" echo=false}
LASTFILE
```

```{.shell cmd="sgf-render %i --format png --outfile %o --width 500 --move-numbers=21-30 -n 30" echo=false}
LASTFILE
```

Let's  continue  with an example using the  statistical  programming  language
[R](https://r-project.org):

```
'``{.shell cmd="Rscript %i %o"}
### outfile is the argument %o
outfile=commandArgs(trailingOnly=TRUE)[1]
png(outfile)
par(mai=rep(0.1,4))
pie(rep(1,20),col=rainbow(20))
dev.off()
'``
```

And here the output:

```{.shell cmd="Rscript %i %o"}
### outfile is the argument %o
outfile=commandArgs(trailingOnly=TRUE)[1]
png(outfile)
par(mai=rep(0.1,4))
pie(rep(1,20),col=rainbow(20))
dev.off()
```

To have compatibility with  [pantcl](https://github.com/mittelmark/pantcl) you
can use as well cmd as the chunk indicator.

```
'``{.cmd cmd="dot -Tpng -o%o %i" echo=false}
digraph g {
  rankdir="LR"
  node[shape=box,style=filled,fillcolor=orange1]
  A -> B -> C
}
'``
```

Output:

```{.cmd cmd="dot -Tpng -o%o %i" echo=false}
digraph g {
    rankdir="LR"
    node[shape=box,style=filled,fillcolor=orange1]
    A -> B -> C
}
```

Error  handling  is as well  implented  let's  say you  have an  error in your
GraphViz code, like a missing curly brace at the end:

```{.cmd cmd="dot -Tpng -o%o %i" echo=true results=hide}
digraph g {
    rankdir="LR"
    node[shape=box,style=filled,fillcolor=orange1]
    A -> B -> C

```

## <a name="kroki">Kroki Webservice Diagrams</a>

The  [kroki.io](https://kroki.io)  webservice allows you to embed diagram code
for many  diagram  tools into your  websites in form of base64  encoding. 
Since  version  0.9.0  _tmdoc_  supports  embedding  of this using  kroki code
chunks.  If the tool wget is  installed  on the users  machine  files  will be
downloaded  and stored  locally,  these files are then used instead of the the
web link. The download is only repeated if the code chunk content does change.
See here for some examples. 


A simple [Ditaa](https://ditaa.sourceforge.net/)  diagram can be created like this:

```
'``{.kroki dia=ditaa imagepath=kroki ext=png}
A --> B
'``
```

Here the output:

```{.kroki dia=ditaa imagepath=kroki ext=png}
A --> B
```

Here an example for a GraphViz Kroki diagram:

```
'``{.kroki dia=graphviz imagepath=kroki ext=png}
digraph a {
   rankdir="LR"
   node[shape=box,style=filled]
   A -> B -> C
}
'``
```

Here the output:

```{.kroki dia=graphviz imagepath=kroki ext=png}
digraph a {
    rankdir="LR"
    node[shape=box,style=filled]
    A -> B -> C
}
```

Using the option `echo=false` we can as well hide the code display:

```
'``{.kroki dia=graphviz ext=png imagepath=kroki echo=false}
digraph a {
   rankdir="LR"
   node[shape=box,style=filled,fillcolor=cornsilk]
   A -> B -> C -> D
}
'``
```

Here the result:

```{.kroki dia=graphviz ext=png imagepath=kroki echo=false}
digraph a {
    rankdir="LR"
    node[shape=box,style=filled,fillcolor=cornsilk]
    A -> B -> C -> D
}
```

## <a name="latex">LaTeX Equations

The  [https://math.vercel.app](https://math.vercel.app)  webservice allows you
to embed LaTeX  equations into your  documents. The equation svg file is downloaded and
cached in the local file system, only if the  equation is changed the file is
downloaded again. Here an example:

```
'``{.mtex}
E = mc^2  \tag{1}
'``
```

Here the output:

```{.mtex}
E = mc^2  \tag{1}
```

Here an example for a matrix:

```
'``{.mtex}
\begin{bmatrix}
1 & 2 & 3 \\      \tag{2}
4 & 5 & 6 
\end{bmatrix}
'``
```

and here the output again:

```{.mtex}
\begin{bmatrix}
1 & 2 & 3 \\      \tag{2}
4 & 5 & 6 
\end{bmatrix}
```

Using the option `echo=false` you can hide the LaTeX code:

```
'``{.mtex echo=false}
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\  \tag{3}
5 & 6 & 7
\end{bmatrix}
'``
```

And here the output  where you only should see the  equation but not the LaTeX
code as `echo` was set to false:

```{.mtex echo=false}
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\  \tag{3}
5 & 6 & 7
\end{bmatrix}
```


## <a name="programming">Programming</a>

Sometimes you would like to prepare programming tutorials where you embed your
code with  explanations  in a Markdown  document and you then like to test the
code and show the output of the  program.  For this  purpose as well  `.shell`
code chunks can be used. The command line should then contain the command line
for compilation and separated with two `&&` symbols the command to execute the
program. Here a simple "Hello World!" script written in the Python programming
language.

```
'``{.shell cmd="python3 %i > %o" chunk.ext=py ext=txt}
print("Hello Python World!")
'``
```

Here the output:
       
```{.shell cmd="python3 %i > %o" chunk.ext=py ext=txt}
print("Hello Python World!")
```

Here an example for a C program:

```
'``{.shell cmd="gcc %i -o hello&&./hello > %o" chunk.ext=c ext=txt}
#include <stdio.h>
int main() {
    printf("Hello C World!\n");
    return(0);
}
'``
```

And here the output:

```{.shell cmd="gcc %i -o hello&&./hello > %o" chunk.ext=c ext=txt}
#include <stdio.h>
int main() {
    printf("Hello C World!\n");
    return(0);
}
```

## <a name='references'>References</a>

Since  version  0.12.0  tmdoc as well  supports the  inclusion of  references.
References can be included like this:

```
This is a references of a paper by Author  [@Author2021].  
```

The author key must be available in a BibTeX file which can be either provided
in the document header in the Yaml section (since tmdoc 0.13.0) like this:

```
---
...
bibliography: filename.bib
...
---
```

Alternatively it can be provided within the text like this:

```{.tcl label=citer eval=false}
package require citer
citer::bibliography filename.bib
```

Here  an  example  for a  citation.  Groth et. al.  have  written  a  nice  PCA  review
[@Groth2013]. In contrast  Sievers et. al. described the Clustal Omega command
line application to align multiple sequences [@Sievers2011].

The  list  of  citations  can be  then  displayed  using  the  tcl  code  'tcl
citer::bibliography'. Here the output:

__References:__

`tcl citer::bibliography`

## <a name="abbrev">Abbreviations</a>

Abbreviations can be defined in a separate Yaml file which should be mentioned in the document preamble like so:

```
---
...
abbreviations: abbrev.yml
...
```

__Here the text:__

```
This is an abbrev {DG} and this is another for the 
Author: {author}. The document was created at {date}. 
This an empty abbreviation {empty}.

Now an abbreviation which is in the `abbrev.yml` file 
- tmdoc is: '{tmdoc}'!
```

__And here the output:__

This is an abbrev {DG} and this is another for the Author: {author}. 
The document was created at {date}. This an empty abbreviation {empty}.

Now an abbreviation which is in the `abbrev.yml` file - tmdoc is: '{tmdoc}'!

Even longer abbreviations can be displayed like:

```
> _{lipsum}_
```

Here the output:

> _{lipsum}_

## <a name="alerts">Alerts</a>

Since version 0.13.0 tmdoc as well supports Alerts for the Markdown output. Alerts are following the same syntax as the 
[Github alerts](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax#alerts):

Here an example:

```
> [!NOTE]
> This is the note text. Note note!!

> [!TIP]
> Do not overload the text with alerts like this!
```

Highlighting is completely managed by the stylesheet. The alerts are placed in
a div tag  with  the name  side-altername  where  alertname  is the  lowercase
version of the altername. See the file [tmdoc.css](tmdoc.css) for a stylesheet
based implementation. The advantage of this approach is that for instance _weasyprint_ can properly convert these to the PDF format.

Here some example:


> [!NOTE]
> This is the note text. Note note!!

> [!TIP]
> Do not overload the text with alerts like this!

> [!IMPORTANT]
> That is very important! Or not??

> [!WARNING]
> This is a warning, warn, warn! This is a warning, warn, warn! This is a warning, warn, warn! This is a warning, warn, warn!

> [!INFO]
> This is an info, info, info! This is an info, info, info!  
> This is an info, info, info!  This is an info, info, info!!!

> [!QUESTION]
> Be or not to be! That is the question!!

> [!ERROR]
> An error happend!

> [!CAUTION]
> This might have consequences!  
> An error can happen!  
> Can we have a third line?

## <a name='csv'>CSV Display</a>

Since version 0.13.0 it is as well to embed CSV (Comma Separated Values) data into the documents and return
the data as text. Here an example:

```{.csv results=asis}
col1,col2,col3,col4
1,2,3,4
5,6,7,8
9,10,11,12
```

As with other code chunks you can as well hide the input by using `echo=false`. Here data from an other table:

```{.csv results=asis echo=false}
col1,col2,col3,col4
11,12,13,14
15,16,17,18
19,20,21,22
```

## <a name="reports">Statistical Reports with R, Python or  Octave</a>

### <a name="rreport">R Code Evaluation</a>

Since  version  0.14.0 we can as well embed R, Python and Octave  code  chunks
within our  documents.  The code will be then  evaluated  step by step and the
output  of the  commands  in text form or as images  can be  displayed  in the
output  document.  That way it is  possible to write  statistical  reports and
scientific  papers  purely in  Markdown  documents.  Code chunks can be either
embedded in code blocks  within  triple back tick code fences or inline in the
text using single back-ticks. The difference of this approach  presented below
using pipes is that the status of the preceding code chunks can be used in the
following  ones. So the status of the  application  is cached  allowing in the
following  code chunks  reuse code and  variables  from the chunks  before. In
contrast the shell based approach  presented  before just isolates every code
chunk as an independent piece of code.

Let' start with a R code  chunk.  Please  note that in the code  example  with
prefix the triple back-ticks with single quotes to avoid interpretation.

```
'```{.pipe pipe="R" results="show"}
data(iris)
png("testr.png")
boxplot(iris$Sepal.Length ~ iris$Species,col=2:4)
dev.off()
print(2)
x=3
'```

![testr.png](testr.png)

```

Here the output of this chunk:


```{.pipe pipe="R" results="show"}
data(iris)
png("testr.png")
boxplot(iris$Sepal.Length ~ iris$Species,col=2:4)
dev.off()
print(2)
x=3
```

![testr.png](testr.png)

As you can see, to create a figure we need to add the `png` and the  `dev.off`
functions and then add the image inclusion as Markdown  command. This can e be
little bit tedious. So instead using the option `fig=true` we can avoid adding the to code lines which open the
figure and the print command to save the image and use the current chunk name.


Here an example:

```
'```{.pipe pipe=R label=rfig fig=true eval=true}
pie(rep(1,each=6),col=rainbow(6))
'```
```

And here the output.

```{.pipe pipe=R label=rfig fig=true eval=true}
pie(rep(1,each=6),col=rainbow(6))
```

Now the next chunk of code which shows that the variable _x_ which was defined
a few chunks  before  still  exists in the current  session-  Using the option
`echo=false` we can as well hide the code chunk and only display the output:

```
'```{.pipe pipe=R results=show echo=false}
print(x)
'```
```

Here the output:

```{.pipe pipe=R results=show echo=false}
print(x)
```

Now again an other  chunk of code where we  increment  x by one and then print
it out:

```{.pipe pipe=R results=show echo=false}
x=x+1
print(x)
```

Variable values of the R session can be as well displayed inline of the normal
text using single back-ticks. Here an example:

```
Now let's show what x is. The variable x has a value of: `r x`.
```

And here the output:

Now let's show what x is. The variable x has a value of: `r x`.

Let' now display a data frame as a table using the `df2md`  function  which is
provided by tmdoc:

Here the code chunk:

```
'```{.pipe pipe=R results=asis echo=false}
df2md(head(iris))
'```
```

And here the output:

```{.pipe pipe=R results=asis echo=false}
df2md(head(iris))
```

The advantage of this pipe based  approach to the shell based  approach,  shown
before, for executing R code is, that the  application  status is continued into
the next code chunk. See here:

```
'```{.pipe pipe=R results=show echo=false}
ls()
print(x)
'```
```

And here the output:


```{.pipe pipe=R results=show echo=false}
ls()
print(x)
```

So variable x still  exists as well in the new code chunk even it was declared
in a chunk earlier. This allows comprehensive analysis in statistical reports.
Usually you should use R packages  like knitr and  rmarkdown for this purpose,
however they are much more demanding. If you install these packages using your
package  manager  you might fill up your hard disk with 2GB of files,  whereas
you can accomplish this with the little __tmdoc__ binary by a single around 200KB large file.

To be  compatible  with  R's  knitr  code  as well  the  following  syntax  is
supported:

```
'```{r results=show echo=false}
y=3
print(y)
'```
```

And here the output:

```{r results=show echo=false}
y=3
print(y)
```

Let's finish the session with a little loop where  continuation  lines should
be rendered with '+' signs:

```
'```{r results=show echo=false}
for (i in 1:4) {
    print(i)
}
'```
```
```{r results=show echo=false}
for (i in 1:4) {
    print(i)
}
```

### <a neme="preport">Python Code Evaluation</a>

As we can use R we can as well use Python in a similar way using the pipe code chunk. Here an example:

```{.pipe pipe=python}
def hello():
    print("Hello Python World!\n")

hello()
x=2
```
  
Again we can use variables declared in the previous code chunks:
 
```{.pipe pipe=python}
print(x)
``` 

We can as well hide the code and only display the session data using the option
`echo=false`.

```{.pipe pipe=python echo=false}
print(x+1)
x=x+1
``` 


It is as well possible to embed inline python code. So the value of Pythons x is
`py print(x)`.

To be more compatible  with  other literature programing tools as well  the  following  syntax  is
supported:

```
'```{py results=show echo=false}
y=3
print(y)
'```
```

And here the output:

```{py results=show echo=false}
y=3
print(y)
```


###  <a name="oreport">Octave Code Evaluation</a>

As we can use R or Python we can as well use an other statistical  programming
language, Octave an open source Matlab clone, in a similar way using the pipe code chunk. Here an example:

```
'```{.pipe pipe=octave}
str = 'Hello Octave World!';
disp(str);
'```
```

And here the output:

```{.pipe pipe=octave}
str = 'Hello Octave World!';
disp(str);
```

Now comes the next code block where we have two _disp_  statements  to display
the value of a variable:

```{.pipe pipe="octave"}  
x=1;
disp(x);
y=2;
disp(y);
```

Now let's do a plot using the _figure_ and the _print_ methods:

```{.pipe pipe="octave"}
aux=figure('visible','off');
tx = ty = linspace (-8, 8, 41);
[xx, yy] = meshgrid (tx, ty);
r = sqrt (xx .^ 2 + yy .^ 2) + eps;
tz = sin (r) ./ r;
mesh (tx, ty, tz);
print(aux, "mesh-octave.png", "-dpng", "-S600,400");
```

![](mesh-octave.png)

Now let's try inline Octave. The value of x is `oc disp(x);`!

Using the option `fig=true` we can avoid adding the to code lines which open the
figure and the print command to save the image and use the current chunk name.

Here an example:

```
'```{.pipe pipe=octave label=oct1 fig=true eval=true}
x = -10:0.1:10;
plot (x, sin (x));
'```
```

And here the output:

```{.pipe pipe=octave label=oct1 fig=true eval=true}
x = -10:0.1:10;
plot (x, sin (x));
```

## <a name='options'>Code Chunk Options</a>

The following  options for Tcl code chunks which are
declared with as _{.tcl}_ are currently  available:

- _echo_: Should the Tcl code be shown, true or false, default: true.
- _eval_: Should the code chunk be evaluated, default: true
- _fig_: Does the code chunk  produces a graphic,  default: false for Tcl code
  If this feature is used there must be a `figure` procedure with a filename argument which writes the figure.
- _include_: Should the created figure automatically displayed, default: false.  It is as well recommended to give the chunk a label, which will be used to create the image filename.
- _label_: Chunk label, helps in debugging and file naming if graphics files are written. default: chunk-nn where nn is the current chunk.
- _results_: Should the output of the Tcl code evaluation be shown, either "hide",
  "asis" or "show", default: "show".

The following code chunk options are available for Shell / Cmd code  which are
declared with _{.cmd}_  or _{.shell}_ as chunks:


- _cmd_: the command line to process the input in the code chunk, the  following
  place holders are available
    - _%i_, _%f_ - the input filename
    - _%o_ - the output filename
    - _%b_ - the basename of the input filename
-  _chunk.ext_ - file  filename  extension  for the code chunk, the default is
txt, but for some tools like for instance a compiler an extension used usually
for that programming language should be used
- _echo_: Should the Input for the command line tool be shown, either true or false, default: true.
- _ext_: file extension for the output file, either a image extension like `png`
    or `svg` or a text extension like `txt` for showing text output, default: png 
- _fig_: Does the code chunk  produces a graphic,  default: true
- _label_: Chunk label, helps in debugging and file naming if graphics files are written. default: chunk-nn where nn is the current chunk.
- _results_: Should the output of the Tcl code evaluation be shown, either "hide",
  "asis" or "show", default: "show".
- _include_: Should the created figure automatically displayed, default: true.
  If set to false it is as well recommended to give the chunk a label, which will be used to create the image filename.

If the same input  should be used with an other  command line  invocation,  as
code chunk should be filled with the text string _LASTFILE_.

Here an example:

```{std}
'``{.cmd cmd="dot -Tpng -o%o %i" echo=false}
digraph g { rankdir="LR"; A -> B -> C }
'``
'``{.cmd cmd="dot -Tpng -Nshape=box -Nstyle=filled -o%o %i" echo=false}
LASTFILE
'``
```

Here the output:

```{.cmd cmd="dot -Tpng -o%o %i" echo=false}
digraph g { rankdir="LR"; A -> B -> C}
```
```{.cmd cmd="dot -Tpng -Nshape=box -Nstyle=filled -o%o %i" echo=false}
LASTFILE
```


The following code chunk options are available for Kroki code chunks which are
declared with _{.kroki}_ :


- _dia_: The  diagram  type such as ditaa,  plantuml,  graphviz,  pikchr  etc,
  default: ditaa
- _echo_: Should the Input for the command line tool be shown, either true or false, default: true.
- _ext_: The file extension, such as pdf, png or svg, default: png
- _fig_: Does the code chunk  produces a graphic,  default: true
- _imagepath_:  The folder where to store the images,  default . (dot, current
  working directory)
- _label_: Chunk label, helps in debugging and file naming if graphics files are written. default: chunk-nn where nn is the current chunk.
- _results_: Should the output of the Tcl code evaluation be shown, either "hide",
  "asis" or "show", default: "show".
- _include_: Should the created figure automatically displayed, default: true.
  If set to false it is as well recommended to give the chunk a label, which will be used to create the image filename.


## <a name="summary">Summary</a>

The `tmdoc::tmdoc`  package provides a literate  programming  proccessor which
extracts and  evaluates Tcl, Shell, LaTeX equations or Diagram code within
code  chunks of Markdown  documents.  The code chunks are  evaluated  by the
`tmdoc`  processor  and replaced  with their output. The code or input and the
output can be shown or hidden due to  specific  configuration  options for the
code chunk.There is as well the  possibility to display images created by Tcl
within  the  document  and  inline  evaluation  of short Tcl  commands  within
backtick  where the first backtick is followed by the character  sequence like
here:  <code>'tcl  set x 1'</code>  (replace  single  quotes with  backticks).
Further  more  there  exists  code to  include  other  files into the  current
document and to work with references stored in BibTeX files.

Code chunks for Tcl code start on lines with three backticks and the character sequence tcl
after  a curly  brace.  They  end at the  next  line  which  has  again  three
backticks (replace the initial single quote with one backticks).

```{std}
'``{.tcl}
set x 1
'``

or Pandoc style

'`` {.tcl}
set x 2
'``
```

## <a name="install">Installation</a>

To install the command line application, just download the latest bin file from the release page of the Github project,
rename it as tmdoc, make it  executable  and move to a directory  belonging to
your PATH variable. 

Here an example:

```
wget https://github.com/mittelmark/tmdoc/releases/download/v0.12.0/tmdoc-0.12.0.bin \
    -O ~/.local/bin/tmdoc
chmod 755 ~/.local/bin/tmdoc
tmdoc --version
## 0.12.0
```

To install the library copy the folder _modules/tmdoc_ to a folder belonging to
your TCLLIBPATH variable. If this variable does not exists you can set it for instance to `~/.local/lib/Tcl8.6` and place the code therein.

## <a name="seealso">See Also</a>

- [tmdoc-package](tmdoc.html)
- [tmdoc-application](../../apps/tmdoc.html)

## <a name="process">Processing Information</a>

```{tcl results=hide echo=false}
package require tmdoc
```


For generating the document the following Tcl version and Tcl packages were used:

* Tcl/Tk `tcl set tcl_patchLevel` 
* tmdoc::tmdoc `tcl package provide tmdoc::tmdoc`

Document was processed at: `tcl clock format [clock seconds] -format "%Y-%m-%d %H:%M"`

Document processing was done within: `tcl expr {[clock milliseconds] - $start}` milliseconds.


